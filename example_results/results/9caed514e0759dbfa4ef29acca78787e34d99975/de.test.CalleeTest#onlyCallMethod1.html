<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Performance Measurement Tree</title>

    <style>
	
	.node {
		cursor: pointer;
	}

	.node circle {
	  fill: #fff;
	  stroke: steelblue;
	  stroke-width: 3px;
	}

	.node text {
	  font: 12px sans-serif;
	}

	.link {
	  fill: none;
	  stroke: #ccc;
	  stroke-width: 2px;
	}
	
    </style>

  </head>

  <body>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script><div style='position:absolute; right: 0px; width: 800px; background-color: #BBBBBB; border: 2px solid blue; border-radius: 1em 1em 1em 1em; padding: 1em;'>
Version: 9caed514e0759dbfa4ef29acca78787e34d99975<br>
Test Case: de.test.CalleeTest#onlyCallMethod1<br>
<a href="#" onclick="collapse();">Collapse</a></div>
<div style='position:absolute; left: 0px; width: 800px; height: 100px; background-color: #BBBBBB; border: 2px solid blue; border-radius: 1em 1em 1em 1em; padding: 1em;' id='infos'>
Statistische Informationen
</div>
<div style='position:absolute; bottom: 0px; width: 600px; height: 300px; background-color: #BBBBBB; border: 2px solid blue; border-radius: 1em 1em 1em 1em; padding: 1em;' id='histogramm'>
Plot
</div>
<div style='position:absolute; bottom: 0px; right:0px; overflow: scroll; width: 1000px; height: 300px; background-color: #BBBBBB; border: 2px solid blue; border-radius: 1em 1em 1em 1em; padding: 1em;' id='quelltext'>
Quelltext
</div>
<div id='tree' style='position: absolute; top: 150px; right: 5px; left: 5px; bottom: 335px; overflow: scroll; border: 2px solid blue; border-radius: 1em 1em 1em 1em;'> </div>
<script>
var source = {"de.test.Callee.method1_": `public void method1() {
    innerMethod();
}`,"de.test.Callee.<init>_": `public Callee() {
    System.out.println("Constructor");
}`,"de.test.Callee.innerMethod_": `private void innerMethod() {										private void innerMethod() {
    try {												    try {
        Thread.sleep(5);									   |	        Thread.sleep(15);
    } catch (final InterruptedException e) {								    } catch (final InterruptedException e) {
        e.printStackTrace();										        e.printStackTrace();
    }													    }
}													}
`,"de.test.CalleeTest.onlyCallMethod1_": `@Test
public void onlyCallMethod1() {
    final Callee callee = new Callee();
    callee.method1();
    Assert.assertNotNull(callee);
}`,};
var treeData = [
{
  "call" : "de.test.CalleeTest#onlyCallMethod1",
  "kiekerPattern" : "public void de.test.CalleeTest.onlyCallMethod1()",
  "otherKiekerPattern" : "public void de.test.CalleeTest.onlyCallMethod1()",
  "name" : "CalleeTest#onlyCallMethod1",
  "key" : "de.test.CalleeTest.onlyCallMethod1_",
  "otherKey" : "de.test.CalleeTest.onlyCallMethod1_",
  "parent" : null,
  "color" : "#FF0000",
  "statistic" : {
    "meanOld" : 5327.0,
    "meanCurrent" : 15367.945,
    "deviationOld" : 71.61577479857336,
    "deviationCurrent" : 16.04425286512441,
    "vms" : 2,
    "callsOld" : 200,
    "calls" : 200,
    "tvalue" : -193.4847971548377,
    "change" : true
  },
  "hasSourceChange" : false,
  "state" : "SLOWER",
  "values" : [ 15379.29, 15356.599999999999 ],
  "valuesPredecessor" : [ 5276.36, 5377.639999999999 ],
  "children" : [ {
    "call" : "de.test.Callee#<init>",
    "kiekerPattern" : "public new de.test.Callee.<init>()",
    "otherKiekerPattern" : "public new de.test.Callee.<init>()",
    "name" : "Callee#<init>",
    "key" : "de.test.Callee.<init>_",
    "otherKey" : "de.test.Callee.<init>_",
    "parent" : "de.test.CalleeTest#onlyCallMethod1",
    "color" : null,
    "statistic" : {
      "meanOld" : 2.745,
      "meanCurrent" : 3.105,
      "deviationOld" : 0.3040559159102162,
      "deviationCurrent" : 0.07778174593051983,
      "vms" : 2,
      "callsOld" : 200,
      "calls" : 200,
      "tvalue" : -1.6221812726135947
    },
    "hasSourceChange" : false,
    "state" : null,
    "values" : [ 3.1599999999999997, 3.0500000000000003 ],
    "valuesPredecessor" : [ 2.960000000000001, 2.53 ],
    "children" : [ ]
  }, {
    "call" : "de.test.Callee#method1",
    "kiekerPattern" : "public void de.test.Callee.method1()",
    "otherKiekerPattern" : "public void de.test.Callee.method1()",
    "name" : "Callee#method1",
    "key" : "de.test.Callee.method1_",
    "otherKey" : "de.test.Callee.method1_",
    "parent" : "de.test.CalleeTest#onlyCallMethod1",
    "color" : "#FF0000",
    "statistic" : {
      "meanOld" : 5189.004999999999,
      "meanCurrent" : 15227.529999999999,
      "deviationOld" : 37.653436098183654,
      "deviationCurrent" : 11.539982668965536,
      "vms" : 2,
      "callsOld" : 200,
      "calls" : 200,
      "tvalue" : -360.48372419770516,
      "change" : true
    },
    "hasSourceChange" : false,
    "state" : "SLOWER",
    "values" : [ 15219.369999999999, 15235.69 ],
    "valuesPredecessor" : [ 5215.629999999999, 5162.379999999999 ],
    "children" : [ {
      "call" : "de.test.Callee#innerMethod",
      "kiekerPattern" : "private void de.test.Callee.innerMethod()",
      "otherKiekerPattern" : "private void de.test.Callee.innerMethod()",
      "name" : "Callee#innerMethod",
      "key" : "de.test.Callee.innerMethod_",
      "otherKey" : "de.test.Callee.innerMethod_",
      "parent" : "de.test.Callee#method1",
      "color" : "#FF0000",
      "statistic" : {
        "meanOld" : 5184.915000000001,
        "meanCurrent" : 15187.319999999998,
        "deviationOld" : 28.050926009671677,
        "deviationCurrent" : 22.21729506488009,
        "vms" : 2,
        "callsOld" : 200,
        "calls" : 200,
        "tvalue" : -395.3083387745348,
        "change" : true
      },
      "hasSourceChange" : true,
      "state" : "SLOWER",
      "values" : [ 15203.029999999997, 15171.609999999999 ],
      "valuesPredecessor" : [ 5165.08, 5204.750000000002 ],
      "children" : [ ]
    } ]
  } ]
}];
// ************** Generate the tree diagram   *****************
var margin = {top: 20, right: 120, bottom: 20, left: 260},
   width = 1000- margin.right - margin.left,
   height = 140 - margin.top - margin.bottom;</script>

<!-- load the d3.js library -->	
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="https://unpkg.com/textures@1.2.0/dist/textures.js"></script>
	
<script>
	
var i = 0,
	duration = 750,
	root;

var tree = d3.layout.tree()
	.size([height, width]);

var diagonal = d3.svg.diagonal()
	.projection(function(d) { return [d.y, d.x]; });

var svg = d3.select("#tree").append("svg")
	.attr("width", width + margin.right + margin.left)
	.attr("height", height + margin.top + margin.bottom)
  .append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var faster_changed = textures.lines()
.background("#00FF00")
.thicker();

var slower_changed = textures.lines()
.background("#FF0000")
.thicker();

var unknown_changed = textures.lines()
.background("#8888FF")
.thicker();

var equal_changed = textures.lines()
.background("#FFF")
.thicker();

svg.call(faster_changed);
svg.call(slower_changed);
svg.call(unknown_changed);
svg.call(equal_changed);

root = treeData[0];
root.x0 = height / 2;
root.y0 = 0;
  
update(root);

d3.select(self.frameElement).style("height", "500px");

function getTexture(node){
  if (node.hasSourceChange)
  { 
    switch (node.state){
	  case 'FASTER': return faster_changed.url();
	  case 'SLOWER': return slower_changed.url();
	  case 'UNKNOWN': return unknown_changed.url();
	  case null: return equal_changed.url();
	}
  }
  else 
	return node.color;
}

function update(source) {
	
  var t = textures.lines()
	  .thicker();

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse(),
	  links = tree.links(nodes);

  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 180; });

  // Update the nodes…
  var node = svg.selectAll("g.node")
	  .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
	  .attr("class", "node")
	  .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
	  .on("click", click)
	  .on("mouseover", shownode);

  nodeEnter.append("circle")
	  .attr("r", 1e-6)
	  .style("fill", function(d) { return getTexture(d); });

  nodeEnter.append("text")
	  .attr("x", function(d) { return d.children || d._children ? -13 : 13; })
	  .attr("dy", ".35em")
	  .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
	  .text(function(d) { return d.name; })
	  .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
	  .duration(duration)
	  .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
	  .attr("r", 10)
	  .style("fill", function(d) {  return getTexture(d); });

  nodeUpdate.select("text")
	  .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
	  .duration(duration)
	  .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
	  .remove();

  nodeExit.select("circle")
	  .attr("r", 1e-6);

  nodeExit.select("text")
	  .style("fill-opacity", 1e-6);

  // Update the links…
  var link = svg.selectAll("path.link")
	  .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
	  .attr("class", "link")
	  .attr("d", function(d) {
		var o = {x: source.x0, y: source.y0};
		return diagonal({source: o, target: o});
	  });

  // Transition links to their new position.
  link.transition()
	  .duration(duration)
	  .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
	  .duration(duration)
	  .attr("d", function(d) {
		var o = {x: source.x, y: source.y};
		return diagonal({source: o, target: o});
	  })
	  .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
	d.x0 = d.x;
	d.y0 = d.y;
  });
}

// Toggle children on click.
function click(d) {
  if (d.children) {
	d._children = d.children;
	d.children = null;
  } else {
	d.children = d._children;
	d._children = null;
  }
  update(d);
}

function round(value){
	return Math.round(value*100)/100;
}

function collapse(){
   root = treeData[0];
   collapseNode(root);
}

function collapseNode(parent){
   for (var nodeId in parent.children) {
      var node=parent.children[nodeId];
      if (node.color == "#5555FF"){
          click(node);
      } else {
	      collapseNode(node);
      }
   }
}

function shownode(node) {
  if (node.statistic != null){
	  infos.innerHTML="<table>" +
      "<tr><th>Predecessor</th><th>Current</th></tr>"+
      "<tr><td>" + round(node.statistic.meanOld) +    "</td><td>" + round(node.statistic.meanCurrent)+"</td></tr>"+
      "<tr><td>" + round(node.statistic.deviationOld)+"</td><td>" + round(node.statistic.deviationCurrent)+"</td></tr>"+
      "</table> VMs: " + node.statistic.vms +
      " T=" + round(node.statistic.tvalue);
  } else {
	  infos.innerHTML = "No statistic";
  }
  if (node.key != node.otherKey){
    quelltext.innerHTML="<pre>" + source[node.key] + "\n\n" + source[node.otherKey] +"</pre>";
  }else{
    quelltext.innerHTML="<pre>" + source[node.key] +"</pre>";
  }
  if (node.kiekerPattern != node.otherKiekerPattern) {
  	histogramm.innerHTML=node.kiekerPattern + " " + node.otherKiekerPattern
  } else {
  	histogramm.innerHTML=node.kiekerPattern
  }
  var version = {
    x: node.values,
    type: "histogram",
    name: "Version",
    opacity: 0.5,
    marker: {
     color: 'green',
    },
  };
  var predecessor = {
    x: node.valuesPredecessor,
    type: "histogram",
    name: "Predecessor",
    opacity: 0.6,
    marker: {
     color: 'red',
    },
  };
  var data = [version, predecessor];
  var layout = {barmode: "overlay", 
			title: { text: "Histogramm"},
			xaxis: { title: { text: "Duration / Mikroseconds"} },
			yaxis: { title: { text: "Frequency"} }
		  };
  Plotly.newPlot("histogramm", data, layout);
}

shownode(root);

</script>
	
  </body>
</html>

